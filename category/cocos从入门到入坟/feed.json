{
    "version": "https://jsonfeed.org/version/1",
    "title": "Florence的城堡 • All posts by \"cocos从入门到入坟\" category",
    "description": "我在这里随便写写",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/01/13/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/",
            "url": "http://example.com/2023/01/13/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/",
            "title": "Cocos入门基础",
            "date_published": "2023-01-13T08:11:15.179Z",
            "content_html": "<p>这个真要准备了…… 真的…… 不过过完年再说 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmNvY29zLmNvbS9jcmVhdG9yL21hbnVhbC96aC8=\">🌝</span></p>\n<h1 id=\"基础\"><a class=\"markdownIt-Anchor\" href=\"#基础\">#</a> 基础</h1>\n<h2 id=\"sprite-的参数\"><a class=\"markdownIt-Anchor\" href=\"#sprite-的参数\">#</a> Sprite 的参数</h2>\n<ul>\n<li>\n<p><code>单色精灵</code> <br>\n一般用于空气墙；</p>\n</li>\n<li>\n<p><code>Atlas</code>  --&gt; Sprite 的 Atlas 图集资源</p>\n</li>\n<li>\n<p>一般来说，我们可以使用第三方工具来进行图片资源压缩。压缩后会生成一个 PNG 大图和一个 plist 文件，这两个文件都需要导入到 CocosCreator 中才可以使用。压缩制作 Atlas 文件，可以使用 <code>Texture Packer</code>  或者 <code>Unity</code>  引擎的 <code>NGUI</code>  都可以</p>\n</li>\n<li>\n<p><code>Sprite Frame</code> <br>\n 渲染 Sprite 使用的 SpriteFrame 图片资源；</p>\n</li>\n<li>\n<p><code>Type</code>  --&gt; 渲染模式<br>\n包括： <code>普通(Simple)</code> 、 <code>九宫格(Sliced)</code> 、 <code>平铺(Tiled)</code> 、 <code>填充(Filled)</code>  和 <code>网格(Mesh)</code> ；</p>\n</li>\n<li>\n<p><code>Size Mode</code>  --&gt; 指定 Sprite 的尺寸</p>\n<ul>\n<li><code>Trimmed</code>  表示会使用原始图片资源裁剪透明像素后的尺寸；</li>\n<li><code>Raw</code>  表示会使用原始图片未经裁剪的尺寸；</li>\n<li><code>Custom</code>  表示会使用自定义尺寸。当用户手动修改过 Node 的 Size 属性后， <code>Size Mode</code>  会被自动设置为 <code>Custom</code> ，除非再次指定为前两种尺寸模式；</li>\n</ul>\n</li>\n<li>\n<p><code>Trim</code> <br>\n 勾选后将在渲染时去除原始图像周围的透明像素区域，<mark>该项仅在 Type 设置为 Simple 时生效</mark>；</p>\n</li>\n<li>\n<p><code>Scr Blend Factor</code> <br>\n 当前图像混合模式；</p>\n</li>\n<li>\n<p><code>Dst Blend Factor</code> <br>\n 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染；</p>\n</li>\n</ul>\n<br>\n<h2 id=\"对脚本语言的支持\"><a class=\"markdownIt-Anchor\" href=\"#对脚本语言的支持\">#</a> 对脚本语言的支持</h2>\n<p>3.0 之后只支持 Typescript，不再支持 JavaScript。不过直接在 TS 中将代码写成 JS 也能执行。</p>\n<h2 id=\"脚本的生命周期函数\"><a class=\"markdownIt-Anchor\" href=\"#脚本的生命周期函数\">#</a> 脚本的生命周期函数</h2>\n<p>目前提供给用户的生命周期回调函数主要有：</p>\n<ul>\n<li><code>onLoad</code>\n<ul>\n<li>组件被加载时调用（第一个被执行）</li>\n</ul>\n</li>\n<li><code>onEnable</code>\n<ul>\n<li>当组件可用时执行</li>\n</ul>\n</li>\n<li><code>start</code>\n<ul>\n<li>初始化时调用，onLoad 执行完后调用</li>\n</ul>\n</li>\n<li><code>update(dt)</code>\n<ul>\n<li>刷新每一帧时调用， <code>dt</code>  代表帧间隔时间</li>\n</ul>\n</li>\n<li><code>lateUpdate</code>\n<ul>\n<li>update 执行完后马上会执行</li>\n</ul>\n</li>\n<li><code>onDisable</code>\n<ul>\n<li>当组件不可用时执行</li>\n</ul>\n</li>\n<li><code>onDestroy</code>\n<ul>\n<li>组件被销毁时调用</li>\n</ul>\n</li>\n</ul>\n<p><mark><strong>Tips</strong></mark></p>\n<p>一个组件从初始化到激活，再到最终销毁的完整生命周期函数调用顺序为： <code>onLoad</code>  -&gt;  <code>onEnable</code>  -&gt;  <code>start</code>  -&gt;  <code>update</code>  -&gt;  <code>lateUpdate</code>  -&gt;  <code>onDisable</code>  -&gt;  <code>onDestroy</code> 。</p>\n<p>其中， <code>onLoad</code>  和  <code>start</code>  常常用于组件的<mark>初始化</mark>，只有在节点  <code>activeInHierarchy</code>  的情况下才能调用，并且最多只会被调用一次。除了上文提到的内容以及调用顺序的不同，它们还有以下区别：</p>\n<ul>\n<li><mark>组件激活时</mark>：\n<ul>\n<li><code>onLoad</code>  立即调用</li>\n<li><code>start</code>  延迟调用</li>\n</ul>\n</li>\n<li><mark>组件 <code>enabled</code>  时是否调用</mark>：\n<ul>\n<li><code>onLoad</code> ❌</li>\n<li><code>start</code> ✅</li>\n</ul>\n</li>\n</ul>\n",
            "tags": []
        }
    ]
}
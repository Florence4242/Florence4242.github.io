{
    "version": "https://jsonfeed.org/version/1",
    "title": "Florence的城堡 • All posts by \"cocos从入门到入坟\" category",
    "description": "我在这里随便写写",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/08/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/",
            "url": "http://example.com/2023/02/08/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/",
            "title": "Cocos入门基础",
            "date_published": "2023-02-08T10:55:22.816Z",
            "content_html": "<h1 id=\"基础\"><a class=\"markdownIt-Anchor\" href=\"#基础\">#</a> 基础</h1>\n<h2 id=\"sprite-的参数\"><a class=\"markdownIt-Anchor\" href=\"#sprite-的参数\">#</a> Sprite 的参数</h2>\n<ul>\n<li>\n<p><code>单色精灵</code> <br>\n一般用于空气墙；</p>\n</li>\n<li>\n<p><code>Atlas</code>  --&gt; Sprite 的 Atlas 图集资源</p>\n</li>\n<li>\n<p>一般来说，我们可以使用第三方工具来进行图片资源压缩。压缩后会生成一个 PNG 大图和一个 plist 文件，这两个文件都需要导入到 CocosCreator 中才可以使用。压缩制作 Atlas 文件，可以使用 <code>Texture Packer</code>  或者 <code>Unity</code>  引擎的 <code>NGUI</code>  都可以</p>\n</li>\n<li>\n<p><code>Sprite Frame</code> <br>\n 渲染 Sprite 使用的 SpriteFrame 图片资源；</p>\n</li>\n<li>\n<p><code>Type</code>  --&gt; 渲染模式<br>\n包括： <code>普通(Simple)</code> 、 <code>九宫格(Sliced)</code> 、 <code>平铺(Tiled)</code> 、 <code>填充(Filled)</code>  和 <code>网格(Mesh)</code> ；</p>\n</li>\n<li>\n<p><code>Size Mode</code>  --&gt; 指定 Sprite 的尺寸</p>\n<ul>\n<li><code>Trimmed</code>  表示会使用原始图片资源裁剪透明像素后的尺寸；</li>\n<li><code>Raw</code>  表示会使用原始图片未经裁剪的尺寸；</li>\n<li><code>Custom</code>  表示会使用自定义尺寸。当用户手动修改过 Node 的 Size 属性后， <code>Size Mode</code>  会被自动设置为 <code>Custom</code> ，除非再次指定为前两种尺寸模式；</li>\n</ul>\n</li>\n<li>\n<p><code>Trim</code> <br>\n 勾选后将在渲染时去除原始图像周围的透明像素区域，<mark>该项仅在 Type 设置为 Simple 时生效</mark>；</p>\n</li>\n<li>\n<p><code>Scr Blend Factor</code> <br>\n 当前图像混合模式；</p>\n</li>\n<li>\n<p><code>Dst Blend Factor</code> <br>\n 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染；</p>\n</li>\n</ul>\n<br>\n<h2 id=\"对脚本语言的支持\"><a class=\"markdownIt-Anchor\" href=\"#对脚本语言的支持\">#</a> 对脚本语言的支持</h2>\n<p>3.0 之后只支持 Typescript，不再支持 JavaScript。不过直接在 TS 中将代码写成 JS 也能执行。</p>\n<h2 id=\"脚本的生命周期函数\"><a class=\"markdownIt-Anchor\" href=\"#脚本的生命周期函数\">#</a> 脚本的生命周期函数</h2>\n<p>目前提供给用户的生命周期回调函数主要有：</p>\n<ul>\n<li><code>onLoad</code>\n<ul>\n<li>组件被加载时调用（第一个被执行）</li>\n</ul>\n</li>\n<li><code>onEnable</code>\n<ul>\n<li>当组件可用时执行</li>\n</ul>\n</li>\n<li><code>start</code>\n<ul>\n<li>初始化时调用，onLoad 执行完后调用</li>\n</ul>\n</li>\n<li><code>update(dt)</code>\n<ul>\n<li>刷新每一帧时调用， <code>dt</code>  代表帧间隔时间</li>\n</ul>\n</li>\n<li><code>lateUpdate(dt)</code>\n<ul>\n<li>update 执行完后马上会执行， <code>dt</code>  代表帧间隔时间</li>\n</ul>\n</li>\n<li><code>onDisable</code>\n<ul>\n<li>当组件不可用时执行</li>\n</ul>\n</li>\n<li><code>onDestroy</code>\n<ul>\n<li>组件被销毁时调用</li>\n</ul>\n</li>\n</ul>\n<p><mark><strong>Tips</strong></mark></p>\n<p>一个组件从初始化到激活，再到最终销毁的完整生命周期函数调用顺序为： <code>onLoad</code>  -&gt;  <code>onEnable</code>  -&gt;  <code>start</code>  -&gt;  <code>update</code>  -&gt;  <code>lateUpdate</code>  -&gt;  <code>onDisable</code>  -&gt;  <code>onDestroy</code> 。</p>\n<p>其中， <code>onLoad</code>  和  <code>start</code>  常常用于组件的<mark>初始化</mark>，只有在节点  <code>activeInHierarchy</code>  的情况下才能调用，并且最多只会被调用一次。除了上文提到的内容以及调用顺序的不同，它们还有以下区别：</p>\n<ul>\n<li>\n<p><mark>组件激活时</mark>：</p>\n<ul>\n<li><code>onLoad</code>  立即调用</li>\n<li><code>start</code>  延迟调用</li>\n</ul>\n</li>\n<li>\n<p><mark>组件 <code>enabled</code>  时是否调用</mark>：</p>\n<ul>\n<li><code>onLoad</code> ❌</li>\n<li><code>start</code> ✅</li>\n</ul>\n<h2 id=\"在脚本中调用节点\"><a class=\"markdownIt-Anchor\" href=\"#在脚本中调用节点\">#</a> 在脚本中调用节点</h2>\n</li>\n<li>\n<p><code>this.node</code> <br>\n 获取当前节点</p>\n</li>\n<li>\n<p><code>node.children</code> <br>\n 获取节点的子节点数组</p>\n</li>\n<li>\n<p><code>node.getChildByName(&quot;name&quot;)</code> <br>\n 通过名称获取子节点</p>\n</li>\n<li>\n<p><code>cc.find(&quot;node1/node2&quot;)</code> <br>\n 根据节点路径获取节点</p>\n</li>\n<li>\n<p><code>node.getParent()</code> <br>\n 获取父节点</p>\n</li>\n<li>\n<p><code>node.setParent(node0)</code> <br>\n 将当前节点设置为 node0 的子节点</p>\n</li>\n<li>\n<p><code>node.removeAllChildren()</code> <br>\n 移除节点的所有子节点</p>\n</li>\n<li>\n<p><code>node.removeChild(node0)</code> <br>\n 移除节子点 node0</p>\n</li>\n<li>\n<p><code>node.removeFromParent()</code> <br>\n 将子节点移除出它的父节点</p>\n</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/02/08/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/",
            "url": "http://example.com/2023/02/08/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/",
            "title": "Cocos入门基础之：交互事件",
            "date_published": "2023-02-08T10:55:22.816Z",
            "content_html": "<h1 id=\"鼠标事件\"><a class=\"markdownIt-Anchor\" href=\"#鼠标事件\">#</a> 鼠标事件</h1>\n<figure class=\"highlight typescript\"><figcaption><span>鼠标事件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(<span class=\"attr\">eventType</span>: <span class=\"title class_\">String</span>, <span class=\"attr\">callback</span>:<span class=\"keyword\">function</span>,<span class=\"attr\">target</span>:<span class=\"built_in\">any</span>,<span class=\"attr\">useCapture</span>:<span class=\"built_in\">boolean</span>);</span><br><span class=\"line\"><span class=\"comment\">// eventType这个参数就代表了具体的鼠标事件名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鼠标点击时获取当前坐标</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&quot;mousedown&quot;</span>, <span class=\"function\">(<span class=\"params\">event:cc.Event.EventMouse</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  cc.<span class=\"title function_\">log</span>(event.<span class=\"title function_\">getLocation</span>() + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(cc.<span class=\"property\">Node</span>.<span class=\"property\">EventType</span>.<span class=\"property\">MOUSE_DOWN</span>, <span class=\"function\">(<span class=\"params\">event:cc.Event.EventMouse</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  cc.<span class=\"title function_\">log</span>(event.<span class=\"title function_\">getLocation</span>() + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>eventType</code>  这个参数就代表了具体的鼠标事件名称，但是如果需要我们死记硬背例如 “mousedown” 之类的字符串显然在开发中容易记错，所以 cocos 为我们定义了一个类  <code>cc.Node.EventType</code> ，用于帮助我们记忆这些事件名。</p>\n</blockquote>\n<ul>\n<li>\n<p><mark><strong>一些鼠标事件</strong></mark></p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MOUSE_DOWN</td>\n<td>鼠标按下</td>\n</tr>\n<tr>\n<td>MOUSE_ENTER</td>\n<td>鼠标移入节点的范围</td>\n</tr>\n<tr>\n<td>MOUSE_LEAVE</td>\n<td>鼠标移出节点的范围</td>\n</tr>\n<tr>\n<td>MOUSE_MOVE</td>\n<td>鼠标移动</td>\n</tr>\n<tr>\n<td>MOUSE_UP</td>\n<td>鼠标松开</td>\n</tr>\n<tr>\n<td>MOUSE_WHEEL</td>\n<td>鼠标滚轮</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><mark><strong>event 函数</strong></mark></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getLocation()</td>\n<td>获取鼠标坐标，2D 返回 cc.vec2，3D 返回 cc.vec3</td>\n</tr>\n<tr>\n<td>getLocationX()</td>\n<td>获取鼠标 x 坐标</td>\n</tr>\n<tr>\n<td>getLocationY()</td>\n<td>获取鼠标 y 坐标</td>\n</tr>\n<tr>\n<td>getButton()</td>\n<td>获取鼠标按键，返回 number，0 代表左键、1 代表滚轮、2 代表右键，当然我们可以使用  <code>cc.Event.EventMouse</code>  类提供的静态属性代替这些 012</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>监听<br>\n可以给一个节点添加事件监听，当然也可以去除监听， <code>this.node.off(eventType)</code>  就可以去除掉相对应的事件监听。</p>\n</li>\n</ul>\n<h1 id=\"键盘事件\"><a class=\"markdownIt-Anchor\" href=\"#键盘事件\">#</a> 键盘事件</h1>\n<blockquote>\n<p>键盘和鼠标事件类似，只不过键盘事件是游戏的全局事件，所以他通过<br>\n <code>cc.systemEvent.on(eventType, callback)</code>  来添加，用法和鼠标事件基本一样：</p>\n</blockquote>\n<ul>\n<li>键盘事件的用法</li>\n</ul>\n<figure class=\"highlight typescript\"><figcaption><span>键盘事件的用法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc.<span class=\"property\">systemEvent</span>.<span class=\"title function_\">on</span>(</span><br><span class=\"line\">  cc.<span class=\"property\">SystemEvent</span>.<span class=\"property\">EventType</span>.<span class=\"property\">KEY_DOWN</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">event: cc.Event.EventKeyboard</span>) =&gt;</span> &#123;&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 这里的event可以拿到对应的键盘按键的编号，比如[A]键等于65。</span></span><br><span class=\"line\"><span class=\"variable constant_\">EY</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>macro.KEY 的使用方法</li>\n</ul>\n<figure class=\"highlight typescript\"><figcaption><span>macro.KEY 的使用方法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc.<span class=\"property\">systemEvent</span>.<span class=\"title function_\">on</span>(</span><br><span class=\"line\">  cc.<span class=\"property\">SystemEvent</span>.<span class=\"property\">EventType</span>.<span class=\"property\">KEY_DOWN</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">event: cc.Event.EventKeyboard</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// cc.log(event.keyCode)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">keyCode</span> === cc.<span class=\"property\">macro</span>.<span class=\"property\">KEY</span>.<span class=\"property\">a</span>) &#123;</span><br><span class=\"line\">      cc.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;按下了a键&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      cc.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;按了其他键&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><mark><strong>一些键盘事件</strong></mark></p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>KEY_UP</td>\n<td>键盘被按下</td>\n</tr>\n<tr>\n<td>KEY_DOWN</td>\n<td>键盘松开</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n<h1 id=\"触摸事件\"><a class=\"markdownIt-Anchor\" href=\"#触摸事件\">#</a> 触摸事件</h1>\n<p>触摸事件和鼠标事件也是一样的，只不过事件类型改为：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TOUCH_START</td>\n<td>触摸开始</td>\n</tr>\n<tr>\n<td>TOUCH_MOVE</td>\n<td>触摸移动</td>\n</tr>\n<tr>\n<td>TOUCH_END</td>\n<td>触摸结束</td>\n</tr>\n<tr>\n<td>TOUCH_CANCEL</td>\n<td>触摸取消</td>\n</tr>\n</tbody>\n</table>\n<p>并且，回调函数中的 event 只有坐标信息，没有按键信息。除此之外，触摸事件比鼠标事件多了一个<mark>多点触控编码</mark>， <code>event.getID()</code>  可以获取到触控的手指编码，第一个是 0，第二个是 1，以此类推</p>\n<ul>\n<li>触摸事件的用法</li>\n</ul>\n<figure class=\"highlight typescript\"><figcaption><span>触摸事件的用法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(cc.<span class=\"property\">Node</span>.<span class=\"property\">EventType</span>.<span class=\"property\">TOUCH_START</span>, <span class=\"function\">(<span class=\"params\">event: cc.Event.EventTouch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  cc.<span class=\"title function_\">log</span>(event.<span class=\"title function_\">getLocation</span>() + <span class=\"string\">&quot;,&quot;</span> + event.<span class=\"title function_\">getID</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义事件\"><a class=\"markdownIt-Anchor\" href=\"#自定义事件\">#</a> 自定义事件</h1>\n<blockquote>\n<p>除了可以使用系统自带的 3 类事件，我们还可以自己定义事件类型。</p>\n</blockquote>\n<p>自定义事件的作用有点类似于 “微信小游戏制作工具” 中的 “通知”，即某些节点在特定情况下可以向其他节点发送通知（触发自定义事件），其他需要监听该自定义事件的节点在收到通知后可以做出响应。<br>\n例如飞机大战中的子弹，当子弹碰撞到敌机时，可以向该敌机发送通知（触发该敌机的自定义事件），该敌机在事件被触发后可以做出相应的操作，例如减血。</p>\n<ul>\n<li><mark><strong>定义自定义事件的监听：</strong></mark><br>\n <code>this.node.on(&quot;myEvent&quot;,callback);</code> ，myEvent 是自定义事件的名称，由我们自己定义。</li>\n</ul>\n<p>触发该自定义事件的方式有两种：</p>\n<ul>\n<li>\n<p><code>this.node.emit(&quot;myEvent&quot;,arg0,arg1,……,arg5);</code>  后面的 arg0~arg5 参数可以有也可以没有，他们是给事件中传递参数用的。</p>\n<figure class=\"highlight typescript\"><figcaption><span>this.node.emit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要触发事件的精灵A中</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&quot;msg&quot;</span>, <span class=\"function\">(<span class=\"params\">arg0: <span class=\"built_in\">Date</span>, arg1: <span class=\"built_in\">String</span>, arg2: <span class=\"built_in\">String</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  cc.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;自定义事件触发&quot;</span> + arg0.<span class=\"title function_\">getFullYear</span>());</span><br><span class=\"line\">  cc.<span class=\"title function_\">log</span>(arg1, arg2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用事件的精灵B中</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">on</span>(cc.<span class=\"property\">Node</span>.<span class=\"property\">EventType</span>.<span class=\"property\">MOUSE_DOWN</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  cc.<span class=\"title function_\">find</span>(<span class=\"string\">&quot;avatar&quot;</span>).<span class=\"title function_\">emit</span>(<span class=\"string\">&quot;msg&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(), <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><mark><strong>分发到事件流</strong></mark></li>\n</ul>\n<figure class=\"highlight typescript\"><figcaption><span>自定义事件-分发到事件流</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> cc.<span class=\"property\">Event</span>.<span class=\"title class_\">EventCustom</span>(<span class=\"string\">&quot;myEvent&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">event.<span class=\"title function_\">setUserData</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">node</span>.<span class=\"title function_\">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>\n<p>其中， <code>event.setUserData()</code>  方法是给自定义事件中添加 <code>detail</code>  属性，这个可以用来传递参数。</p>\n</li>\n</ul>\n",
            "tags": []
        }
    ]
}
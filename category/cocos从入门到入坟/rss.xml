<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Florence的城堡 • Posts by &#34;cocos从入门到入坟&#34; category</title>
        <link>http://example.com</link>
        <description>我在这里随便写写</description>
        <language>zh-CN</language>
        <pubDate>Mon, 30 Jan 2023 17:04:16 +0800</pubDate>
        <lastBuildDate>Mon, 30 Jan 2023 17:04:16 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/30/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</guid>
            <title>Cocos入门基础</title>
            <link>http://example.com/2023/01/30/Cocos%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/Cocos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Mon, 30 Jan 2023 17:04:16 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;这个真要准备了…… 真的…… 不过过完年再说 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLmNvY29zLmNvbS9jcmVhdG9yL21hbnVhbC96aC8=&#34;&gt;🌝&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;基础&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基础&#34;&gt;#&lt;/a&gt; 基础&lt;/h1&gt;
&lt;h2 id=&#34;sprite-的参数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sprite-的参数&#34;&gt;#&lt;/a&gt; Sprite 的参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;单色精灵&lt;/code&gt; &lt;br&gt;
一般用于空气墙；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Atlas&lt;/code&gt;  --&amp;gt; Sprite 的 Atlas 图集资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般来说，我们可以使用第三方工具来进行图片资源压缩。压缩后会生成一个 PNG 大图和一个 plist 文件，这两个文件都需要导入到 CocosCreator 中才可以使用。压缩制作 Atlas 文件，可以使用 &lt;code&gt;Texture Packer&lt;/code&gt;  或者 &lt;code&gt;Unity&lt;/code&gt;  引擎的 &lt;code&gt;NGUI&lt;/code&gt;  都可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Sprite Frame&lt;/code&gt; &lt;br&gt;
 渲染 Sprite 使用的 SpriteFrame 图片资源；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Type&lt;/code&gt;  --&amp;gt; 渲染模式&lt;br&gt;
包括： &lt;code&gt;普通(Simple)&lt;/code&gt; 、 &lt;code&gt;九宫格(Sliced)&lt;/code&gt; 、 &lt;code&gt;平铺(Tiled)&lt;/code&gt; 、 &lt;code&gt;填充(Filled)&lt;/code&gt;  和 &lt;code&gt;网格(Mesh)&lt;/code&gt; ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Size Mode&lt;/code&gt;  --&amp;gt; 指定 Sprite 的尺寸&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trimmed&lt;/code&gt;  表示会使用原始图片资源裁剪透明像素后的尺寸；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Raw&lt;/code&gt;  表示会使用原始图片未经裁剪的尺寸；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Custom&lt;/code&gt;  表示会使用自定义尺寸。当用户手动修改过 Node 的 Size 属性后， &lt;code&gt;Size Mode&lt;/code&gt;  会被自动设置为 &lt;code&gt;Custom&lt;/code&gt; ，除非再次指定为前两种尺寸模式；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Trim&lt;/code&gt; &lt;br&gt;
 勾选后将在渲染时去除原始图像周围的透明像素区域，&lt;mark&gt;该项仅在 Type 设置为 Simple 时生效&lt;/mark&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Scr Blend Factor&lt;/code&gt; &lt;br&gt;
 当前图像混合模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Dst Blend Factor&lt;/code&gt; &lt;br&gt;
 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;对脚本语言的支持&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#对脚本语言的支持&#34;&gt;#&lt;/a&gt; 对脚本语言的支持&lt;/h2&gt;
&lt;p&gt;3.0 之后只支持 Typescript，不再支持 JavaScript。不过直接在 TS 中将代码写成 JS 也能执行。&lt;/p&gt;
&lt;h2 id=&#34;脚本的生命周期函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#脚本的生命周期函数&#34;&gt;#&lt;/a&gt; 脚本的生命周期函数&lt;/h2&gt;
&lt;p&gt;目前提供给用户的生命周期回调函数主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onLoad&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;组件被加载时调用（第一个被执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onEnable&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当组件可用时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;初始化时调用，onLoad 执行完后调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;刷新每一帧时调用， &lt;code&gt;dt&lt;/code&gt;  代表帧间隔时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lateUpdate(dt)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;update 执行完后马上会执行， &lt;code&gt;dt&lt;/code&gt;  代表帧间隔时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDisable&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当组件不可用时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDestroy&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;组件被销毁时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;一个组件从初始化到激活，再到最终销毁的完整生命周期函数调用顺序为： &lt;code&gt;onLoad&lt;/code&gt;  -&amp;gt;  &lt;code&gt;onEnable&lt;/code&gt;  -&amp;gt;  &lt;code&gt;start&lt;/code&gt;  -&amp;gt;  &lt;code&gt;update&lt;/code&gt;  -&amp;gt;  &lt;code&gt;lateUpdate&lt;/code&gt;  -&amp;gt;  &lt;code&gt;onDisable&lt;/code&gt;  -&amp;gt;  &lt;code&gt;onDestroy&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;其中， &lt;code&gt;onLoad&lt;/code&gt;  和  &lt;code&gt;start&lt;/code&gt;  常常用于组件的&lt;mark&gt;初始化&lt;/mark&gt;，只有在节点  &lt;code&gt;activeInHierarchy&lt;/code&gt;  的情况下才能调用，并且最多只会被调用一次。除了上文提到的内容以及调用顺序的不同，它们还有以下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;组件激活时&lt;/mark&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onLoad&lt;/code&gt;  立即调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt;  延迟调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;组件 &lt;code&gt;enabled&lt;/code&gt;  时是否调用&lt;/mark&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onLoad&lt;/code&gt; ❌&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt; ✅&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在脚本中调用节点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#在脚本中调用节点&#34;&gt;#&lt;/a&gt; 在脚本中调用节点&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;this.node&lt;/code&gt; &lt;br&gt;
 获取当前节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.children&lt;/code&gt; &lt;br&gt;
 获取节点的子节点数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.getChildByName(&amp;quot;name&amp;quot;)&lt;/code&gt; &lt;br&gt;
 通过名称获取子节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cc.find(&amp;quot;node1/node2&amp;quot;)&lt;/code&gt; &lt;br&gt;
 根据节点路径获取节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.getParent()&lt;/code&gt; &lt;br&gt;
 获取父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.setParent(node0)&lt;/code&gt; &lt;br&gt;
 将当前节点设置为 node0 的子节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.removeAllChildren()&lt;/code&gt; &lt;br&gt;
 移除节点的所有子节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.removeChild(node0)&lt;/code&gt; &lt;br&gt;
 移除节子点 node0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;node.removeFromParent()&lt;/code&gt; &lt;br&gt;
 将子节点移除出它的父节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
